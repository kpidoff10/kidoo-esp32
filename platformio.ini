; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html
;
; ============================================
; Architecture multi-plateforme ESP32
; ============================================
; Ce projet supporte plusieurs plateformes ESP32 avec un seul code source :
; - ESP32-S3 (Basic, Gotchi) : Dual-core + PSRAM
; - ESP32-C3 (Mini, Dream)  : Single-core RISC-V
;
; La détection du chip est automatique via core_config.h
; Les pins GPIO sont définis dans models/{basic|mini|dream|gotchi}/config/config.h
;
; ============================================
; SD / FatFs (ff.h) - Compatibilité ESP32-S3 et ESP32-C3
; ============================================
; La lib SD Arduino (espressif32) utilise FatFs (ff.h). Sur certaines versions
; de la plateforme, le build ESP32-S3 peut échouer avec "ff.h: No such file or directory".
; Solution : fixer une version de plateforme où les chemins FatFs sont corrects pour
; les deux cibles (C3 et S3). On utilise la lib SD du framework, pas de lib externe.
; Si l'erreur persiste avec 6.4.0, tester espressif32 @ 6.7.0 ou 6.8.0.

[platformio]
default_envs = basic

; ============================================
; Configuration commune (valeurs par défaut)
; ============================================
; Fichiers sources communs à tous les modèles :
; - main.cpp
; - models/common/** (tous les managers communs)
; - models/model_config.h
; - models/model_init.h
; - models/model_pubnub_routes.h
; - models/model_serial_commands.h

[env]
; Version fixée pour garantir SD/FatFs (ff.h) sur ESP32-S3 et ESP32-C3 (un seul repo, multi-target).
platform = espressif32 @ 6.4.0
framework = arduino
; Note: build_src_filter est défini dans chaque environnement spécifique
; car PlatformIO ne fusionne pas les listes lors de l'héritage

platform_packages = tool-esptoolpy@~1.40501.0

; Flags de compilation communs
build_flags = 
	-DARDUINO_USB_MODE=1
	-DARDUINO_USB_CDC_ON_BOOT=1
	-DCORE_DEBUG_LEVEL=0
	-Os
	-ffunction-sections
	-fdata-sections
	-Wl,--gc-sections
	; FastLED RMT driver natif ESP32
	-DFASTLED_ESP32_FLASH_LOCK=1

; Dépendances communes
lib_deps = 
	adafruit/Adafruit NeoPixel@^1.12.4
	bblanchon/ArduinoJson@^7.0.0

; Configuration Serial Monitor commune
monitor_speed = 115200
monitor_dtr = 0
monitor_rts = 0
upload_speed = 921600

; ============================================
; Environnement Basic - ESP32-S3
; ============================================
; Board: ESP32-S3-DevKitC-1 (AYWHP / ESP-1-N16R8)
;   - 16MB Flash QD / 8MB PSRAM OPI
;   - 2x USB-C: USB-OTG (UART) + USB-JTAG (debug)
;   - LED RGB intégrée sur GPIO 48

[env:basic]
; Hérite de [env] et surcharge les valeurs spécifiques
board = esp32-s3-devkitc-1
board_build.partitions = default_16MB.csv
board_build.flash_mode = qio
board_upload.flash_size = 16MB
; PSRAM OPI 8MB - Configuration mémoire pour N16R8
board_build.arduino.memory_type = qio_opi

; Filtrage des sources : fichiers communs (hérités) + répertoire basic
; Les fichiers communs sont définis ici car PlatformIO ne fusionne pas build_src_filter
build_src_filter = 
	+<main.cpp>
	+<models/common/**>
	+<models/model_config.h>
	+<models/model_init.h>
	+<models/model_pubnub_routes.h>
	+<models/model_serial_commands.h>
	+<models/basic/**>

build_flags = 
	${env.build_flags}
	-DKIDOO_MODEL_BASIC
	-DKIDOO_MODEL_ID=\"basic\"
	; LED RGB intégrée DevKitC-1
	-DBUILTIN_RGB_LED_PIN=48
	; PSRAM 8MB OPI
	-DBOARD_HAS_PSRAM

; Dépendances supplémentaires pour Basic (NFC, Audio)
lib_deps = 
	${env.lib_deps}
	adafruit/Adafruit PN532@^1.3.4
	https://github.com/schreibfaul1/ESP32-audioI2S.git

; ============================================
; Environnement Mini - ESP32-C3
; ============================================
; Board: ESP32-C3-DevKitM-1 ou équivalent
;   - 4MB Flash
;   - Pas de PSRAM
;   - Single-core RISC-V 160MHz
;   - WiFi + BLE 5.0
;   - USB natif (pas besoin de convertisseur USB-Serial)

[env:mini]
; Hérite de [env] (platform 6.4.0, framework arduino). ESP32-C3 uniquement.
board = esp32-c3-devkitm-1
; Utiliser huge_app.csv pour avoir 3MB pour l'app (au lieu de 1.25MB par défaut)
board_build.partitions = huge_app.csv
board_build.flash_mode = dio

; Filtrage des sources : fichiers communs (hérités) + répertoire mini
; Les fichiers communs sont définis ici car PlatformIO ne fusionne pas build_src_filter
; Le code audio est automatiquement exclu via #ifdef HAS_AUDIO (non défini dans mini/config/config.h)
build_src_filter = 
	+<main.cpp>
	+<models/common/**>
	+<models/model_config.h>
	+<models/model_init.h>
	+<models/model_pubnub_routes.h>
	+<models/model_serial_commands.h>
	+<models/mini/**>

build_flags = 
	${env.build_flags}
	-DKIDOO_MODEL_MINI
	-DESP32C3
	; FastLED RMT driver - 2 canaux pour C3
	-DFASTLED_RMT_MAX_CHANNELS=2
	; Optimisations supplémentaires pour réduire la taille du firmware
	-ffast-math

; Dépendances communes uniquement (pas de NFC/Audio sur Mini)
lib_deps = 
	${env.lib_deps}

; Ignorer explicitement les bibliothèques non compatibles avec ESP32-C3
lib_ignore = 
	ESP32-audioI2S
	Adafruit PN532

; ============================================
; Environnement Dream - ESP32-S3
; ============================================
; Board: ESP32-S3-DevKitC-1 (AYWHP / ESP-1-N16R8)
;   - 16MB Flash QD / 8MB PSRAM OPI
;   - 2x USB-C: USB-OTG (UART) + USB-JTAG (debug)
;   - LED RGB intégrée sur GPIO 48

[env:dream]
; Hérite de [env] (platform 6.4.0, framework arduino). ESP32-C3 uniquement.
board = esp32-c3-devkitm-1
; OTA nécessite 2 partitions (ota_0 + ota_1). huge_app n'a qu'app0, donc OTA échouait (Update.begin "No Error").
; partitions_dream_ota.csv : ota_0 et ota_1 ~1.66 MB chacun (firmware ~1.6 MB)
board_build.partitions = partitions_dream_ota.csv
board_build.flash_mode = dio

; Filtrage des sources : fichiers communs (hérités) + répertoire mini
; Les fichiers communs sont définis ici car PlatformIO ne fusionne pas build_src_filter
; Le code audio est automatiquement exclu via #ifdef HAS_AUDIO (non défini dans mini/config/config.h)
build_src_filter = 
	+<main.cpp>
	+<models/common/**>
	+<models/model_config.h>
	+<models/model_init.h>
	+<models/model_pubnub_routes.h>
	+<models/model_serial_commands.h>
	+<models/dream/**>

build_flags = 
	${env.build_flags}
	-DKIDOO_MODEL_DREAM
	-DKIDOO_MODEL_ID=\"dream\"
	-DHAS_WIFI
	-DHAS_SD
	-DESP32C3
	; Optimisations supplémentaires pour réduire la taille du firmware
	-ffast-math

; Dépendances communes uniquement (pas de NFC/Audio sur Mini)
lib_deps = 
	${env.lib_deps}

; Ignorer explicitement les bibliothèques non compatibles avec ESP32-C3
lib_ignore = 
	ESP32-audioI2S
	Adafruit PN532

; ============================================
; Environnement Gotchi - ESP32-S3-N16R8
; ============================================
; Board: ESP32-S3 (N16R8 = 16MB Flash QD / 8MB PSRAM OPI)
;   - 16MB Flash QD / 8MB PSRAM OPI
;   - Dual-core Xtensa LX7 240MHz
;   - LED RGB intégrée sur GPIO 48 (si DevKitC-1)

[env:gotchi]
; Hérite de [env] (platform 6.4.0, framework arduino). ESP32-S3-N16R8.
board = esp32-s3-devkitc-1
board_build.partitions = default_16MB.csv
board_build.flash_mode = qio
board_upload.flash_size = 16MB
board_build.arduino.memory_type = qio_opi

; --- Upload sans tenir BOOT à chaque fois ---
; La carte a 2 ports USB : UART (souvent marqué "UART" ou "USB") et USB-JTAG/CDC.
; Brancher le câble sur le port UART pour l'upload : le circuit DTR/RTS de ce port
; fait entrer la carte en bootloader automatiquement. Si vous flashez via l'autre port
; (USB natif), il n'y a pas d'auto-reset → il faut tenir BOOT + RESET à la main.
; Dans le Gestionnaire de périphériques, le port UART = souvent "Silicon Labs" ou "CP210x".
; Upload : vitesse réduite pour éviter "Write timeout". Si OK, remonter à 921600.
upload_speed = 460800
; Serial après upload (USB CDC) :
; - Utiliser le MÊME câble USB que pour l'upload, ou l'autre port pour le moniteur.
; - Après upload : attendre 2-3 s puis lancer le moniteur (le COM peut changer).
monitor_speed = 115200
monitor_dtr = 0
monitor_rts = 0

build_src_filter = 
	+<main.cpp>
	+<models/common/**>
	+<models/model_config.h>
	+<models/model_init.h>
	+<models/model_pubnub_routes.h>
	+<models/model_serial_commands.h>
	+<models/gotchi/**>

; USB-CDC On Boot : console série sur USB natif (S3) au démarrage, pas besoin de UART externe
build_flags = 
	${env.build_flags}
	-DARDUINO_USB_CDC_ON_BOOT=1
	-DARDUINO_USB_MODE=1
	-DKIDOO_MODEL_GOTCHI
	-DKIDOO_MODEL_ID=\"gotchi\"
	-DHAS_WIFI
	-DHAS_SD
	-DBOARD_HAS_PSRAM
	-DBUILTIN_RGB_LED_PIN=48

; LCD ST7789 (texte / image) - LovyanGFX
lib_deps = 
	${env.lib_deps}
	lovyan03/LovyanGFX

; ============================================
; Gotchi UART — Serial sur UART au lieu de USB CDC
; ============================================
; Si le moniteur série ne marche pas avec [env:gotchi] (USB CDC), utilise cet env :
; - Serial sort sur UART0 (souvent relié au 2e port USB "UART" de la carte).
; - Flasher : env "gotchi_uart" puis Upload. Ouvrir le moniteur sur le port UART (souvent l'autre prise USB).
; - Carte avec 1 seul USB : adaptateur USB-série sur TX0 (GPIO43) / RX0 (GPIO44).
